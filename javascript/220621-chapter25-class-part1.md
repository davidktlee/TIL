# TIL 

# 클래스

## 클래스와 생성자 함수의 차이

1. 클래스는 new 연산자 필수, 생성자 함수는 new 없으면 일반 함수
2. 클래스는 상속을 지원하는 extends와 super 키워드를 제공한다.
3. 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다.
4. 클래스 내의 모든 코드에는 암묵적으로 strict mode가 지정된다.
5. 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 열거되지 않는다.

→ 클래스는 새로운 객체 생성 메커니즘으로 보는 것이 합당하다.

## 클래스 정의

파스칼 케이스로 정의하고 표현식으로 클래스를 정의 할 수 있으며, 일급 객체이다.

## 클래스 호이스팅

클래스는 함수로 평가된다.

클래스 선언문으로 정의한 클래스는 런타임 이전에 먼저 평가되어 함수 객체를 생성한다.

단, 클래스는 클래스 정의 이전에 참조할 수 없다.

## 인스턴스 생성

클래스는 생성자 함수이며 new 연산자와 함께 호출되어 인스턴스를 생성한다.

## 메서드

클래스 내부에서 정의할 수 있는 메서드는 constructor, 프로토타입 메서드, 정적 메서드이다.

```tsx
class Person {
	constructor(name){
		this.name = name
	}
}
const lee = new Person('lee')
console.log(lee) // person{name: 'lee'}
```

클래스의 contructor 프로퍼티는 클래스 자신을 가리킨다. 즉, 클래스가 인스턴스를 생성하는 생성자 함수라는 것을 뜻한다.

클래스의 constructor는 메서드로 해석되는 것이 아니라, 클래스 정의가 평가되면 constructor의

기술된 동작을 하는 함수 객체가 생성된다.

**프로토타입의 constructor 프로퍼티와 클래스의 constructor 메서드는 관련이 없다.**

### 프로토타입 메서드

생성자 함수와는 다르게 프로토타입 프로퍼티에 메서드를 추가하지 않아도 기본적으로 프로토타입 메서드가 된다.

### 정적 메서드

클래스에서는 메서드 앞에 `static` 키워드를 붙이면 정적 메서드가 된다.

정적 메서드는 인스턴스로 호출할 수 없다. 정적 메서드가 바인딩된 클래스는 인스턴스의 프로토타입 체인상에 존재하지 않게 때문이다.

### 프로토타입과 정적메서드 차이

1. 자신이 속해 있는 프로토타입 체인이 다르다.
2. 정적 메서드는 클래스로 호출, 프로토타입 메서드는 인스턴스로 호출
3. 정적 메서드는 인스턴스 프로퍼티 참조 불가능, 프로토타입 메서드는 인스턴스 프로퍼티 참조.

## this

메서드 내부에서 인스턴스 프로퍼티를 참조할 필요가 있다면 this를 사용해야 하고, 그 때 프로토타입 메서드로 정의해야 한다.

this를 사용하지 않는 메서드는 정적 메서드로 정의 하는것이 좋다.

## 클래스의 인스턴스 생성 과정

```jsx
class Person {
	constructor(name) {
		// 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다.
		// console.log(this) // Person{}
		// 이 때 인스턴스의 프로토타입으로 클래스의 prototype 프로퍼티가 가리키는 객체가 설정된다.
	this.name = name
	// 2. this에 바인딩 되어 있는 인스턴스 초기화
	// 3. 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.
	}
}
```

## 프로퍼티

인스턴스 프로퍼티는 constructor 내부에서 정의해야 한다.
